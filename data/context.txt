Computing in this book is framed in terms of processes, procedures, and computers. A process is any change that happens over time: water boiling, a person learning to ride a bike, or a bank account balance changing after transactions. A procedure is a precise description of how to carry out a process: a recipe, a step-by-step algorithm, or a set of instructions that a computer (or a person) could follow without needing extra judgment or creativity. A computer is a physical machine we can program with procedures so that it reliably carries out processes for us.

The book emphasizes that computer science is really the study of information processes. Computer scientists ask: how do we describe a process precisely, predict how it will behave, and implement it efficiently? Instead of just solving one instance of a problem, we define a procedure that solves all instances of a certain form. We then analyze how many steps, how much memory, and how much other resources the procedure consumes as the input size grows.

The text distinguishes between information, data, and representation. Information is the abstract content: for example, “today’s temperature is 20 degrees Celsius”. Data is a concrete encoding of that information: a number stored in memory, or characters in a file. A representation is the mapping between the abstract information and the data: for example, deciding that we will represent temperatures as 32-bit integers counting tenths of a degree, or that we will use UTF-8 bytes to represent characters. The same information can have many different representations, and choosing a good representation often makes procedures simpler or more efficient.

Computers have become dramatically more powerful over the last several decades. The book discusses the growth of computing power in terms of both hardware improvements and algorithmic advances. Hardware gets faster and cheaper, allowing us to execute more instructions per second and store more data. But improvements in algorithms are equally important: a better procedure can reduce the number of required steps from millions to thousands for the same input size. A central theme is that we care not only about what is computable at all, but also about how the cost scales as problems get larger.

The introductory chapter also compares science, engineering, and the liberal arts perspectives on computing. In the scientific view, we build models and theories of information processes and test them against reality. In the engineering view, we design and construct reliable systems that solve real problems under constraints like time, cost, and safety. From a liberal-arts perspective, computing is part of how we understand the world and ourselves: it changes how we think about language, logic, creativity, and even what it means to “explain” something. The book argues that computing should be seen as a modern liberal art, not just a technical skill for specialists.

Procedures and abstractions are presented as fundamental tools. When we define a procedure, we hide low-level details behind a meaningful name, so we can reason at a higher level. For example, once we have a procedure that sorts a list, other parts of a program can just use “sort(list)” without knowing exactly which sorting algorithm is implemented. Good abstractions make it possible to build very complex systems out of simpler pieces, and to change the implementation of a piece without breaking everything else.

The chapter also connects computing to how we represent different kinds of information. Text can be represented as sequences of characters, which themselves are encoded as numbers (like Unicode code points). Images can be represented as grids of pixels, each pixel having numbers for its color components. Sound can be represented as a sequence of sampled amplitudes. Once information is represented as data, computers can apply procedures to transform, analyze, and transmit it.

Overall, the introduction positions computer science as the study of general methods for describing and manipulating information processes, grounded in precise procedures and careful reasoning about cost, capabilities, and limitations. It motivates why these ideas are valuable not only for building software, but also for developing clearer ways of thinking about problems in many domains.